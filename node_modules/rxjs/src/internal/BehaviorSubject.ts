import { Subject } from './Subject';
import { Subscriber } from './Subscriber';
import { Subscription } from './Subscription';
<<<<<<< HEAD
=======
import { SubscriptionLike } from './types';
import { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

/**
 * A variant of Subject that requires an initial value and emits its current
 * value whenever it is subscribed to.
 *
 * @class BehaviorSubject<T>
 */
export class BehaviorSubject<T> extends Subject<T> {
<<<<<<< HEAD
=======

>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
  constructor(private _value: T) {
    super();
  }

  get value(): T {
    return this.getValue();
  }

<<<<<<< HEAD
  /** @internal */
  protected _subscribe(subscriber: Subscriber<T>): Subscription {
    const subscription = super._subscribe(subscriber);
    !subscription.closed && subscriber.next(this._value);
=======
  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>): Subscription {
    const subscription = super._subscribe(subscriber);
    if (subscription && !(<SubscriptionLike>subscription).closed) {
      subscriber.next(this._value);
    }
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    return subscription;
  }

  getValue(): T {
<<<<<<< HEAD
    const { hasError, thrownError, _value } = this;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  }

  next(value: T): void {
    super.next((this._value = value));
=======
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  }

  next(value: T): void {
    super.next(this._value = value);
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
  }
}
