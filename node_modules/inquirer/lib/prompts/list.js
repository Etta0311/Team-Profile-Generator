'use strict';
/**
 * `list` type prompt
 */

<<<<<<< HEAD
const _ = {
  isNumber: require('lodash/isNumber'),
  findIndex: require('lodash/findIndex'),
  isString: require('lodash/isString'),
};
const chalk = require('chalk');
const figures = require('figures');
const cliCursor = require('cli-cursor');
const runAsync = require('run-async');
const { flatMap, map, take, takeUntil } = require('rxjs/operators');
const Base = require('./base');
const observe = require('../utils/events');
const Paginator = require('../utils/paginator');
const incrementListIndex = require('../utils/incrementListIndex');
=======
var _ = require('lodash');
var chalk = require('chalk');
var figures = require('figures');
var cliCursor = require('cli-cursor');
var runAsync = require('run-async');
var { flatMap, map, take, takeUntil } = require('rxjs/operators');
var Base = require('./base');
var observe = require('../utils/events');
var Paginator = require('../utils/paginator');
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

class ListPrompt extends Base {
  constructor(questions, rl, answers) {
    super(questions, rl, answers);

    if (!this.opt.choices) {
      this.throwParamError('choices');
    }

    this.firstRender = true;
    this.selected = 0;

<<<<<<< HEAD
    const def = this.opt.default;
=======
    var def = this.opt.default;
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

    // If def is a Number, then use as index. Otherwise, check for value.
    if (_.isNumber(def) && def >= 0 && def < this.opt.choices.realLength) {
      this.selected = def;
    } else if (!_.isNumber(def) && def != null) {
<<<<<<< HEAD
      const index = _.findIndex(
        this.opt.choices.realChoices,
        ({ value }) => value === def
      );
=======
      let index = _.findIndex(this.opt.choices.realChoices, ({ value }) => value === def);
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
      this.selected = Math.max(index, 0);
    }

    // Make sure no default is set (so it won't be printed)
    this.opt.default = null;

<<<<<<< HEAD
    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;
    this.paginator = new Paginator(this.screen, { isInfinite: shouldLoop });
=======
    this.paginator = new Paginator(this.screen);
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
  }

  /**
   * Start the Inquiry session
   * @param  {Function} cb      Callback when prompt is done
   * @return {this}
   */

  _run(cb) {
    this.done = cb;

<<<<<<< HEAD
    const self = this;

    const events = observe(this.rl);
=======
    var self = this;

    var events = observe(this.rl);
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    events.normalizedUpKey.pipe(takeUntil(events.line)).forEach(this.onUpKey.bind(this));
    events.normalizedDownKey
      .pipe(takeUntil(events.line))
      .forEach(this.onDownKey.bind(this));
    events.numberKey.pipe(takeUntil(events.line)).forEach(this.onNumberKey.bind(this));
    events.line
      .pipe(
        take(1),
        map(this.getCurrentValue.bind(this)),
<<<<<<< HEAD
        flatMap((value) =>
          runAsync(self.opt.filter)(value, self.answers).catch((err) => err)
        )
=======
        flatMap(value => runAsync(self.opt.filter)(value).catch(err => err))
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
      )
      .forEach(this.onSubmit.bind(this));

    // Init the prompt
    cliCursor.hide();
    this.render();

    return this;
  }

  /**
   * Render the prompt to screen
   * @return {ListPrompt} self
   */

  render() {
    // Render question
<<<<<<< HEAD
    let message = this.getQuestion();
=======
    var message = this.getQuestion();
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

    if (this.firstRender) {
      message += chalk.dim('(Use arrow keys)');
    }

    // Render choices or answer depending on the state
    if (this.status === 'answered') {
      message += chalk.cyan(this.opt.choices.getChoice(this.selected).short);
    } else {
<<<<<<< HEAD
      const choicesStr = listRender(this.opt.choices, this.selected);
      const indexPosition = this.opt.choices.indexOf(
        this.opt.choices.getChoice(this.selected)
      );
      const realIndexPosition =
        this.opt.choices.reduce((acc, value, i) => {
          // Dont count lines past the choice we are looking at
          if (i > indexPosition) {
            return acc;
          }
          // Add line if it's a separator
          if (value.type === 'separator') {
            return acc + 1;
          }

          let l = value.name;
          // Non-strings take up one line
          if (typeof l !== 'string') {
            return acc + 1;
          }

          // Calculate lines taken up by string
          l = l.split('\n');
          return acc + l.length;
        }, 0) - 1;
      message +=
        '\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);
=======
      var choicesStr = listRender(this.opt.choices, this.selected);
      var indexPosition = this.opt.choices.indexOf(
        this.opt.choices.getChoice(this.selected)
      );
      message +=
        '\n' + this.paginator.paginate(choicesStr, indexPosition, this.opt.pageSize);
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    }

    this.firstRender = false;

    this.screen.render(message);
  }

  /**
   * When user press `enter` key
   */

  onSubmit(value) {
    this.status = 'answered';

    // Rerender prompt
    this.render();

    this.screen.done();
    cliCursor.show();
    this.done(value);
  }

  getCurrentValue() {
    return this.opt.choices.getChoice(this.selected).value;
  }

  /**
   * When user press a key
   */
  onUpKey() {
<<<<<<< HEAD
    this.selected = incrementListIndex(this.selected, 'up', this.opt);
=======
    var len = this.opt.choices.realLength;
    this.selected = this.selected > 0 ? this.selected - 1 : len - 1;
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    this.render();
  }

  onDownKey() {
<<<<<<< HEAD
    this.selected = incrementListIndex(this.selected, 'down', this.opt);
=======
    var len = this.opt.choices.realLength;
    this.selected = this.selected < len - 1 ? this.selected + 1 : 0;
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    this.render();
  }

  onNumberKey(input) {
    if (input <= this.opt.choices.realLength) {
      this.selected = input - 1;
    }

    this.render();
  }
}

/**
 * Function for rendering list choices
 * @param  {Number} pointer Position of the pointer
 * @return {String}         Rendered content
 */
function listRender(choices, pointer) {
<<<<<<< HEAD
  let output = '';
  let separatorOffset = 0;
=======
  var output = '';
  var separatorOffset = 0;
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

  choices.forEach((choice, i) => {
    if (choice.type === 'separator') {
      separatorOffset++;
      output += '  ' + choice + '\n';
      return;
    }

    if (choice.disabled) {
      separatorOffset++;
      output += '  - ' + choice.name;
      output += ' (' + (_.isString(choice.disabled) ? choice.disabled : 'Disabled') + ')';
      output += '\n';
      return;
    }

<<<<<<< HEAD
    const isSelected = i - separatorOffset === pointer;
    let line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;
=======
    var isSelected = i - separatorOffset === pointer;
    var line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    if (isSelected) {
      line = chalk.cyan(line);
    }

    output += line + ' \n';
  });

  return output.replace(/\n$/, '');
}

module.exports = ListPrompt;
