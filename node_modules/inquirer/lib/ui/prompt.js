'use strict';
<<<<<<< HEAD
const _ = {
  isPlainObject: require('lodash/isPlainObject'),
  clone: require('lodash/clone'),
  isArray: require('lodash/isArray'),
  get: require('lodash/get'),
  set: require('lodash/set'),
  isFunction: require('lodash/isFunction'),
};
const { defer, empty, from, of } = require('rxjs');
const { concatMap, filter, publish, reduce } = require('rxjs/operators');
const runAsync = require('run-async');
const utils = require('../utils/utils');
const Base = require('./baseUI');
=======
var _ = require('lodash');
var { defer, empty, from, of } = require('rxjs');
var { concatMap, filter, publish, reduce } = require('rxjs/operators');
var runAsync = require('run-async');
var utils = require('../utils/utils');
var Base = require('./baseUI');
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

/**
 * Base interface class other can inherits from
 */

class PromptUI extends Base {
  constructor(prompts, opt) {
    super(opt);
    this.prompts = prompts;
  }

<<<<<<< HEAD
  run(questions, answers) {
    // Keep global reference to the answers
    if (_.isPlainObject(answers)) {
      this.answers = _.clone(answers);
    } else {
      this.answers = {};
    }

    // Make sure questions is an array.
    if (_.isPlainObject(questions)) {
      // It's either an object of questions or a single question
      questions = Object.values(questions).every(
        (v) => _.isPlainObject(v) && v.name === undefined
      )
        ? Object.entries(questions).map(([name, question]) => ({ name, ...question }))
        : [questions];
=======
  run(questions) {
    // Keep global reference to the answers
    this.answers = {};

    // Make sure questions is an array.
    if (_.isPlainObject(questions)) {
      questions = [questions];
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    }

    // Create an observable, unless we received one as parameter.
    // Note: As this is a public interface, we cannot do an instanceof check as we won't
    // be using the exact same object in memory.
<<<<<<< HEAD
    const obs = _.isArray(questions) ? from(questions) : questions;
=======
    var obs = _.isArray(questions) ? from(questions) : questions;
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

    this.process = obs.pipe(
      concatMap(this.processQuestion.bind(this)),
      publish() // Creates a hot Observable. It prevents duplicating prompts.
    );

    this.process.connect();

    return this.process
      .pipe(
        reduce((answers, answer) => {
<<<<<<< HEAD
          _.set(answers, answer.name, answer.answer);
          return answers;
        }, this.answers)
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this), this.onError.bind(this));
=======
          _.set(this.answers, answer.name, answer.answer);
          return this.answers;
        }, {})
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this));
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
  }

  /**
   * Once all prompt are over
   */

  onCompletion() {
    this.close();

    return this.answers;
  }

<<<<<<< HEAD
  onError(error) {
    this.close();
    return Promise.reject(error);
  }

  processQuestion(question) {
    question = _.clone(question);
    return defer(() => {
      const obs = of(question);
=======
  processQuestion(question) {
    question = _.clone(question);
    return defer(() => {
      var obs = of(question);
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab

      return obs.pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'message', this.answers)
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'default', this.answers)
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)
        ),
        concatMap(this.fetchAnswer.bind(this))
      );
    });
  }

  fetchAnswer(question) {
<<<<<<< HEAD
    const Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() =>
      from(this.activePrompt.run().then((answer) => ({ name: question.name, answer })))
=======
    var Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() =>
      from(
        this.activePrompt.run().then(answer => ({ name: question.name, answer: answer }))
      )
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    );
  }

  setDefaultType(question) {
    // Default type to input
    if (!this.prompts[question.type]) {
      question.type = 'input';
    }

    return defer(() => of(question));
  }

  filterIfRunnable(question) {
<<<<<<< HEAD
    if (
      question.askAnswered !== true &&
      _.get(this.answers, question.name) !== undefined
    ) {
      return empty();
    }

=======
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    if (question.when === false) {
      return empty();
    }

    if (!_.isFunction(question.when)) {
      return of(question);
    }

<<<<<<< HEAD
    const { answers } = this;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then((shouldRun) => {
=======
    var answers = this.answers;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then(shouldRun => {
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
          if (shouldRun) {
            return question;
          }
        })
<<<<<<< HEAD
      ).pipe(filter((val) => val != null))
=======
      ).pipe(filter(val => val != null))
>>>>>>> ba354fa661b4c6906c0342221d686a312a23a3ab
    );
  }
}

module.exports = PromptUI;
